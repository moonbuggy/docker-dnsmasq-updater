# shellcheck shell=bash disable=SC2034
DMU_VERSION="2.0.3"

DEFAULT_PYTHON_VERSION='3.11'

SSL_LIBRARY='openssl'

# WHEEL_REPO="moonbuggy2000/python-musl-wheels"
WHEEL_REPO="moonbuggy2000/python-alpine-wheels"

# these should be available from PyPi now
#PYTHON_WHEELS="paramiko-${SSL_LIBRARY} python-hosts"

# but keep paramiko so we can choose the SSL library, but also because it will
# include the pre-built cryptography wheel (which isn't available from PyPi)
PYTHON_WHEELS="bottlejwt paramiko-${SSL_LIBRARY}"

# Alpine has no cargo or rust packages for s390x
EXCLUDED_ARCHES='s390x'

declare -A BUILD_ARGS=( \
	[BUILD_PYTHON_VERSION]='Python version' \
	[SSL_LIBRARY]='SSL library' \
	[IMPORTS_DIR]='Imports dir' \
	[AGENT_STRING]='agent string' \
	[API_BACKEND]='API backend' \
	[PYPI_INDEX]='PyPi index' \
	[APK_PROXY]='APK proxy' \
)

declare -A CHECKOUT_DISPLAY=( \
	[BUILD_PYTHON_VERSION]='Python version' \
	[DOCKER_FILE]='Dockerfile' \
	[SSL_LIBRARY]='SSL library' \
	[DMU_VERSION]='DMU version' \
	[DMU_LATEST]='DMU repo latest' \
	[is_latest]='Building latest' \
	[AGENT_STRING]='agent string' \
	[PYPI_INDEX]='PyPi index' \
)

env_end () {
	TARGET_TAG='alpine'
	SOURCE_REPO='moonbuggy2000/alpine-s6-python'
	ALPINE_VERSION="3.18"
	ARCH_YAML='hooks/arch.alpine.yaml'
	API_BACKEND='gunicorn'
	unset AGENT_STRING

	case "${DOCKER_TAG}" in
		agent*)
			TARGET_TAG='agent'
			unset PYTHON_WHEELS
			AGENT_STRING='_agent'
			unset API_BACKEND
			;;&
		*binary*)
			TARGET_TAG="${TARGET_TAG}-binary"
			SOURCE_REPO='moonbuggy2000/alpine-s6'
			DOCKER_FILE='Dockerfile.binary'
			;;
	esac

	TARGET_TAG="${DMU_VERSION}-${TARGET_TAG}"

	[ -z "${SOURCE_REPO+set}" ] \
		&& echo "Can't build tag '${DOCKER_TAG}'." \
		&& exit 1
}

post_checkout_start () {
	add_param "${PYTHON_VERSION:-${DEFAULT_PYTHON_VERSION}}" 'BUILD_PYTHON_VERSION'

	case "${TARGET_TAG}" in
		*binary) SOURCE_TAG="${ALPINE_VERSION}" ;;
		*) SOURCE_TAG="${BUILD_PYTHON_VERSION}-alpine${ALPINE_VERSION}" ;;
	esac

	add_param "$(docker_api_latest ${DOCKER_REPO})" 'DMU_LATEST'

	# add extra tags if we're building the latest version
	unset is_latest

	# assume version strings with alphabetical characters in them are beta/dev
	# build. i.e. let us use '1.1-dev' and the like for test builds without pushing
	# a new 'alpine', 'alpine-binary' or 'latest' tag to Docker Hub.
	[ "${DMU_VERSION//[[:alpha:]]/}" = "${DMU_VERSION}" ] \
		&& [ "$(printf '%s\n%s\n' "${DMU_LATEST}" "${DMU_VERSION}" | sort -V | tail -n1)" = "${DMU_VERSION}" ] \
		&& is_latest=1
}

# strip the version from the target tag if this is the latest version
get_base_tags () {
	[ ! -z ${is_latest+set} ] && echo "${TARGET_TAG#*-}"
}

## extra tags to add during post_push
get_manifest_tags () {
	local extra_tags && extra_tags=()

	case "${TARGET_TAG}" in
		*alpine)
			extra_tags+=("${DMU_VERSION}-script" "${DMU_VERSION}")
			[ ! -z ${is_latest+set} ] && extra_tags+=('script' 'latest' 'alpine')
			;;
		*alpine-binary)
			extra_tags+=("${DMU_VERSION}-binary")
			[ ! -z ${is_latest+set} ] && extra_tags+=('binary')
			;;
		*agent)
			extra_tags+=("${DMU_VERSION}-agent")
			[ ! -z ${is_latest+set} ] && extra_tags+=('agent')
			;;
		*agent-binary)
			extra_tags+=("${DMU_VERSION}-agent-binary")
			[ ! -z ${is_latest+set} ] && extra_tags+=('agent-binary')
			;;
	esac

	echo "${extra_tags[@]}"
}
